<html class="html">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <style type="text/css">
    #map {
      width:100%;
      height:600px;
    }

    .buttons {
      position: absolute;
      top: 10px;
      right: 10px;
      margin: 0;
    }
  </style>
</head>
<body>

  <div id="map">
  </div>
  <div class="btn-group btn-group-sm buttons" role="group" aria-label="...">
    <button id="modePanAndZoom" type="button" class="btn btn-default"><span class="glyphicon glyphicon-move" aria-hidden="true"></span> Pan & Zoom Map</button>
    <button id="modeScratchoff" type="button" class="btn btn-default"><span class="glyphicon glyphicon-edit" aria-hidden="true"></span> Scratch Off!</button>
  </div>


  <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
  <!--  // <script src="js/l.canvasoverlay.js"></script> -->
  <script src="https://code.jquery.com/jquery-2.1.4.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mustache.js/2.2.0/mustache.js"></script>
  <script src="js/data.js" charset="utf-8"></script>
  <script>
    var isDrawing,
    currentOffset,
    scratchoffMode = false,
    radius,
    fillColor,
    strokeColor;

    var map = L.map('map').setView([40.7,-73.99], 14);

    //Add bottom layer
    L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{
      maxZoom: 20,
      subdomains:['mt0','mt1','mt2','mt3']
    }).addTo(map);



    //add top (canvas tile) layer
    var canvasTiles = L.tileLayer.canvas({tileSize:256,unloadInvisibleTiles:true});

    canvasTiles.drawTile = function(canvas, tilePoint, zoom) {
      var ctx = canvas.getContext('2d');
      var img = new Image();
      img.src = Mustache.render("scripts/tiles/{{z}}/{{x}}/{{y}}.png",{
        z: zoom,
        x:tilePoint.x,
        y:tilePoint.y
      })
      img.onload = function() {
        ctx.drawImage(img,0,0);
      };   
    };
    canvasTiles.addTo(map);

    //TODO: viewreset is triggered before the canvas elements load.
    //setListeners() must be called after all of the canvas elements exist.
    //figure out what even to listen for (canvasTiles.on('load') does not work either)
    map.on('viewreset',function(){
      setTimeout(function() {
        setListeners();
      },1000)
    })
    setListeners();

    canvasTiles.on('tileload',function() {
      setListeners();
    })


    //Button Group Click Handlers
    $('#modePanAndZoom').click(function(){
      //Enable drag and zoom handlers.
      map.dragging.enable();
      map.touchZoom.enable();
      map.doubleClickZoom.enable();
      map.scrollWheelZoom.enable();

      scratchoffMode = false;
    });

    $('#modeScratchoff').click(function(){
      //Disable drag and zoom handlers.
      map.dragging.disable();
      map.touchZoom.disable();
      map.doubleClickZoom.disable();
      map.scrollWheelZoom.disable();

      scratchoffMode = true;
    });

    //when the canvaslayer adds new canvas tiles, these listeners need to be set again
    function setListeners() {
      $("canvas").unbind()
        .mousemove(function(e) {
          if(scratchoffMode) {
            draw($(this),e);
          }
        })

        .mousedown(function(e) {
        if(scratchoffMode) {
            isDrawing=true;
            draw($(this),e);
          } 
        })

        .mouseup(function(e) {
        if(scratchoffMode) {
          isDrawing=false;
        }
      })   
    }

    var fillCircle = function(x, y, radius, fillColor, strokeColor  ) {
      this.moveTo(x, y);

      //draw the stroke
      this.globalCompositeOperation = 'source-over';
      this.lineWidth = 2;
      this.strokeStyle = strokeColor;
      this.arc(x, y, radius, 0, Math.PI * 2, false);
      this.stroke();

      //draw the fill
      this.globalCompositeOperation = 'destination-out';
      this.fillStyle = fillColor;
      this.arc(x, y, radius-5, 0, Math.PI * 2, false);
      this.fill();
    };

    function draw(element, e) {
      if(!isDrawing) {
        return
      }
      var x = e.offsetX;
      var y = e.offsetY;

      radius = 30; // or whatever
      fillColor = '#ff0000';
      strokeColor = '#ffffff';

      //check to see if the cursor is near the edge of a tile
      var buffer = { 
        top: (y < radius ? true : false),
        right: (x > (256-radius) ? true : false),
        left: (x < radius ? true : false),
        bottom: (y > (256-radius) ? true : false)
      }

  

      if( buffer.top || buffer.right || buffer.bottom || buffer.left ) {
        outerDraw(element, buffer,x,y);
      }
      

      // //whichever are true, draw in those as well
      // (top ? outerDraw(element,'top'):null);
      // (bottom ? outerDraw(element,'bottom'):null);
      // (left ? outerDraw(element,'left'):null);
      // (right ? outerDraw(element,'right'):null);


      var ctx = element[0].getContext('2d');

      ctx.fillCircle = fillCircle;
      


      ctx.fillCircle(x, y, radius, fillColor, strokeColor);
    }

function outerDraw(element, buffer,drawX,drawY) {
  var origin = {
    top: element[0].offsetTop,
    left: element[0].offsetLeft
  }

  //build an array of tiles to be drawn into
  //set bounds of target based on which directions are true in buffer
  var range = {
    xMin: origin.left,
    xMax: origin.left+256,
    yMin: origin.top,
    yMax: origin.top+256
  }

  if (buffer.top) {
    range.yMin = origin.top - 256;
  }
  if (buffer.right) {
    range.xMax = origin.left + 512;
  }
  if (buffer.bottom) {
    range.yMax = origin.top + 512;
  }
  if (buffer.left) {
    range.xMin = origin.left - 256;
  }

  console.log($('canvas').length)

  $('canvas').each(function(i) {
    var x = parseInt($(this).css('left')),
      y = parseInt($(this).css('top'));

    if(x==origin.left && y==origin.top) {
      return
    }

    if( x >= range.xMin && x < range.xMax ) {
      if( y >= range.yMin && y < range.yMax ) {
      
        var ctx = this.getContext('2d');

        ctx.fillCircle = fillCircle;
      
        var offsetX = origin.left - x,
        offsetY = origin.top - y;
  

        ctx.fillCircle(drawX + offsetX, drawY + offsetY, radius, fillColor, strokeColor);
      }
    }
  });
}

</script>

</body>
</html>